key,content

Jörn Fischer j.fischer@hs-mannheim.de,Jörn Fischer\n\nj.fischer@hs-mannheim.de\n\nWillkommen zur Vorlesung\n\nProgrammieren 1\n\n

Überblick Inhalt (roter Faden),"Überblick\n\nInhalt (roter Faden)\n\n1 - Organisatorisches\n\n2 - Einführung\n\n3 - Programmentwurf\n\n4 - Erste Schritte\n\n  9 - Arrays, Enumerationen\n\n10 - Methoden/ Funktionen\n\n11 - Rekursion\n\n12 - Klassen, Objekte\n\n5 - Die Programmiersprache Java\n\n13 - Vererbung\n\n6 - Variablen und Datentypen\n\n7 - Arithmetische Ausdrücke\n\n8 - Anweisungen (Schleifen, \n\nbedingte Verzweigungen)\n\n14 - Referenzen\n\n15 - Interfaces\n\n16 - Exceptions \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 3\n\n"

1 - Organisatorisches Kapitel 1 - Organisatorisches,1 - Organisatorisches\n\nKapitel 1 - Organisatorisches\n\n Übungen\n\n Prüfungsvoraussetzung\n\n Fragen an mich\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\n

1 - Organisatorisches Übungen,"1 - Organisatorisches\n\nÜbungen\n\nÜbungsstunden finden in 2'er oder 3'er Gruppen statt\n\nIn den Übungen besteht Anwesenheitspflicht!\n\n Wenn ihr krank seid, reicht bitte eine Krankmeldung vom Arzt ein.\n\n\n\n2 mal unentschuldigt fehlen führt zum Ausschluss von der Klausur\n\n Wer sich letztes Semester schon für die Klausur qualifiziert hat, wende sich \n\nbitte per Mail an mich!\n\nEs gibt alle zwei Wochen neue Übungsblätter\n\nZusätzlich werde ich mehrere Life-Testate einführen\n\n\n\n\n\n\n\n\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 6\n\n"

1 - Organisatorisches Prüfungsvoraussetzung,1 - Organisatorisches\n\nPrüfungsvoraussetzung\n\nAnwesenheit in den Übungsstunden\n\n\n\n\n\n(davon 20 Pkte Life-Testat)\n\nMindestens n x 100 von n x 120 Punkten bei n Pflichtübungen \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 7\n\n

1 - Organisatorisches Fragen an mich...,1 - Organisatorisches\n\nFragen an mich...\n\n\n\n\n\n\n\nFragen können gerne auch per Email an mich gerichtet werden oder aber \n\nbei Diskussionsbedarf einfach per Mail einen Termin vereinbaren...\n\nRückkopplung ist ausdrücklich erwünscht !!!!!\n\nZwischen den Vorlesungen bin ich oft kurz angebunden; darum besser in \n\nden Übungsstunden fragen.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 8\n\n

2 - Einführung Kapitel 2 - Einführung,2 - Einführung\n\nKapitel 2 - Einführung\n\n Welches Buch kann ich lesen?\n\n\n\nDie Programmiersprache Java.\n\n Wie funktioniert ein Computer?\n\n Welche Zahlensysteme werden benutzt?\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 11\n\n

2 - Einführung Welches Buch kann ich lesen,"2 - Einführung\n\nWelches Buch kann ich lesen\n\nEs gibt unglaublich viele Bücher über Java (auch online)\n\n\n\n\n\nSinnvoll für dieses Semester ist es, wenn Sie sich erst einmal ein Buch aus der \n\nBibliothek über Java-Programmierung ausleihen.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 12\n\n 2 - Einführung\n\nWelches Buch kann ich lesen\n\nEinführung in die Informatrik, Heinz-Peter Gumm, Manfred Sommer\n\nJava ist auch eine Insel, Galileo Computing, 1480 Seiten\n\nGrundkurs Programmieren in JAVA,  Carl Hanser Verlag GmbH, 711 Seiten\n\nJava von Kopf bis Fuß, O' Reilly, 720 Seiten\n\nMein Favorit: JAVA Eine Einführung, Martin Schrader, Lars Schmidt-Thiemen, \n\nSpringer, 635 Seiten (leider nicht mehr aufgelegt, also nur in der Bibliothek)\n\nTaschenbuch Programmiersprachen, Hanser, 631 Seiten, 31 Seiten JAVA (Nur \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nals Überblick)\n\nusw....\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 13\n\n"

2 - Einführung Die Programmiersprache Java,"2 - Einführung\n\nDie Programmiersprache Java\n\n\n\n\n\n\n\n\n\n\n\nEntwicklung in Assembler ist sehr aufwendig (schlecht portier- und wartbar) \n\nProgrammiersprache B, angelehnt an BCPL (Basic Combined \n\nProgramming Language)\n\nEntwicklung von C, im Gegensatz zu B typisiert\n\nJava hat viele Teile der Syntax von C/ C++ übernommen, hat aber Altlasten \n\nwie die Aufteilung in Header und Source Files über Bord geworfen\n\nJava ist durch VM (Virtuelle Maschine) unabhängig von Hardware und \n\nBetriebssystem\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 15\n\n"

2 - Einführung Die Programmiersprache Java - warum?,"2 - Einführung\n\nDie Programmiersprache Java - warum?\n\nauf vielen Plattformen lauffähig\n\ngroße Bibliothek und auf vielen Plattformen verwendbar\n\nEin-/ Ausgabe, Dateioperationen\n\neinfach\n\nschnell\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGUI\n\nZeichenkettenverarbeitung\n\n Mathematik\n\n\n\nusw...\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 16\n\n"

2 - Einführung Die Programmiersprache Java (aber...),2 - Einführung\n\nDie Programmiersprache Java (aber...)\n\n\n\n\n\n\n\n\n\n\n\nJava for Android hat komplett andere GUI Implementierung\n\nJava ist nicht ohne Jailbreak auf iPhone und iPad zu installieren\n\nJava kann nicht ohne große langsame Umwege auf spezielle Hardware \n\nzugreifen \n\nEs gibt nicht das Graphical User Interface (GUI) … z.B. Swing vs. AWT …\n\nCompilierte Java Klassen lassen sich relativ leicht wieder in Quellcode \n\numwandeln (schränkt die Verwendung für kommerzielle Produkte ein)\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 17\n\n

2 - Einführung Was passiert mit einem selbst geschriebenen Programm?,"2 - Einführung\n\nWas passiert mit einem selbst geschriebenen Programm?\n\nJava Quellcode\n\nJava-Compiler\n\nJava Bytecode\n\nVirtuelle Maschine\n\nProzessor\n\n\n\n\n\nJava-Programme liegen als Quellcode vor\n\nEin Programm kann aus mehreren \n\nDateien bestehen, in denen i.Allg. jeweils \n\neine Klassen implementiert ist.\n\n\n\nEine dieser Klassen implementiert die \n\nMethode public static void main(String [] \n\narg) , die beim Starten automatisch \n\nausgeführt wird.\n\n Wir werden zunächst nur mit \n\nProgrammen arbeiten, die aus einer \n\neinzelnen Datei bestehen.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 18\n\n"

2 - Einführung Wie funktioniert ein Computer,"2 - Einführung\n\nWie funktioniert ein Computer\n\nEin Computer folgt dem EVA Prinzip: Eingabe, Verarbeitung, Ausgabe\n\n\n\n\n\nIm Computer gibt es u.a. \n\nCPU (Central Processing Unit), die Recheneinheit\n\nRAM (Random Access Memory)\n\nROM (Read only Memory) bzw. Flash-Memory für das BIOS (Basic Input \n\nOutput System)\n\nFestplattenspeicher oder SSD (Solid State Disk)\n\n– Grafikkarte\n\nInterfaces (Schnittstellen)\n\n–\n\n–\n\n–\n\n–\n\n–\n\n–\n\nBus Systeme (z.B. USB = Universal Serial Bus, PCI-Express) meistens \n\nbestehend aus Daten- und Adressbus\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 19\n\n 2 - Einführung\n\nWie funktioniert ein Computer\n\n\n\nEs gibt unzählige Computerarchitekturen. Wichtig für die Programmierung ist \n\nbeispielsweise die Unterteilung in   \n\nVon Neumann Architektur                         Harvard Architektur\n\n             Moderner PC                           manche Digitalen Signal Prozessoren   \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 21\n\n"

2 - Einführung Zahlensysteme und Umwandlung,"2 - Einführung\n\nZahlensysteme und Umwandlung\n\nZahlensysteme sind Stellenwert-Systeme.\n\n\n\n\n\nJeder Stelle ist ein Vervielfachungsfaktor in Form einer Potenzzahl \n\nzugeordnet.\n\nmögliche Ziffern).\n\n\n\nBeim Dezimalsystem ist jede Stelle einer Zehnerpotenz zugeordnet (10 \n\n\n\nBeim Binärsystem ist jede Stelle einer Zweierpotenz zugeordnet (2 \n\nmögliche Ziffern pro Stelle).\n\n\n\nBeim Hexadezimalsystem ist jede Stelle einer Sechzehnerpotenz \n\nzugeordnet (16 mögliche Ziffern).\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 22\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Dezimal in Hexadezimal:\n\n4025 / 16 = 251 Rest 9  -> 9 (letzte Stelle ganz rechts)\n\n251  / 16 = 15  Rest 11 -> B\n\n15   / 16 = 0   Rest 15 -> F (erste Stelle ganz links)\n\nDez\n\n165\n\n164\n\n163\n\n162\n\n161\n\n160\n\n1048576\n\n65536\n\n4096\n\n256\n\n16\n\n4025\n\n0\n\n0\n\n0\n\nF\n\nB\n\n1\n\n9\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 23\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Dezimal in Binär:\n\n185 / 2 = 92 Rest 1 (Least Significant Bit -> LSB)\n\n92  / 2 = 46 Rest 0\n\n46  / 2 = 23 Rest 0\n\n23  / 2 = 11 Rest 1\n\n11  / 2 = 5  Rest 1\n\n5   / 2 = 2  Rest 1\n\n2   / 2 = 1  Rest 0\n\n1   / 2 = 0  Rest 1 (Most Significant Bit -> MSB)\n\n27\n\n128\n\n26\n\n64\n\n0\n\n25\n\n32\n\n1\n\n24\n\n16\n\n1\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n0\n\n20\n\n1\n\n1\n\nBinär\n\n1\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 24\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Binär in Dezimal:\n\n185 = 128 + 32 + 16 + 8 + 1\n\n27\n\n128\n\n26\n\n64\n\n0\n\n25\n\n32\n\n1\n\n24\n\n16\n\n1\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n0\n\n20\n\n1\n\n1\n\nBinär\n\n1\n\n\n\nSummiert man die Zahlen, über den Einsen einer Binärzahl, so erhält \n\nman die Dezimalzahl (s.o.)\n\nAlternativ kann auch verschachtelt vorgegangen werden:\n\n185 = ((((((((1)*2+0)*2+1)*2+1)*2+1)*2+0)*2+0)*2+1)\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 25\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Binär in Hexadezimal:\n\n1011bin = 11dez = Bhex\n\n1001bin = 9dez  = 9hex \n\n1011 1001bin  = B9hex\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n1\n\n20\n\n1\n\n1\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n0\n\n20\n\n1\n\n1\n\nBinär\n\n\n\nDie Binärzahl wird von rechts nach links in 4‘er Gruppen eingeteilt und  \n\njede Hex. Ziffer einzeln umgewandelt.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 26\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Hexadezimal in Binär:\n\nB9hex enthält Ziffern „B“ und „9“\n\nBhex = 11dez = 1011bin\n\n9hex =  9dez = 1001bin\n\nB9hex = 1011 1001bin\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n1\n\n20\n\n1\n\n1\n\n23\n\n8\n\n1\n\n22\n\n4\n\n0\n\n21\n\n2\n\n0\n\n20\n\n1\n\n1\n\nBinär\n\n\n\nJede Hex. Ziffer wird einzeln in Binär umgewandelt!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 27\n\n 2 - Einführung\n\nZahlensysteme und Umwandlung\n\nWandlung von Hexadezimal in Dezimal:\n\nFB9hex enthält Ziffern „F“, „B“ und „9“\n\nFHEX = 15dez\n\nBhex  = 11dez\n\n9hex  =  9dez\n\nDez\n\n165\n\n164\n\n163\n\n162\n\n161\n\n160\n\n \n\n1048576\n\n65536\n\n4096\n\n256\n\n16\n\n4025\n\n0\n\n0\n\n0\n\nF\n\nB\n\n1\n\n9\n\nFB9hex = 15 * 256  +  16 * 11  +  9 * 1 = 4025dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 28\n\n"

3 - Programmentwurf       Kapitel 3 - Programmentwurf,3 - Programmentwurf      \n\nKapitel 3 - Programmentwurf\n\n\n\n\n\n\n\nAlgorithmenbegriff\n\nAktivitätsdiagramm\n\nPseudocode\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 30\n\n

3 - Programmentwurf       Algorithmenbegriff:,3 - Programmentwurf      \n\nAlgorithmenbegriff:\n\n\n\nEin Algorithmus ist ein Verfahren mit einer\n\npräzisen (d.h. in einer genau festgelegten Sprache formulierten)\n\nendlichen Beschreibung unter Verwendung\n\n effektiver (d.h. tatsächlich ausführbarer)\n\n elementarer Verarbeitungsschritte\n\n\n\nEin Algorithmus benötigt nur endlich viele Ressourcen:\n\n\n\n\n\n\n\n\n\nRechenzeit\n\nSpeicher\n\nEin Algorithmus ist unabhängig von der Programmiersprache.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 31\n\n

3 - Programmentwurf       Aktivitätsdiagramm,"3 - Programmentwurf      \n\nAktivitätsdiagramm\n\n\n\nStandardisierte Notation für Abläufe\n\nBestandteil der UML (Unified Modeling Language)\n\nBasiert auf Programmablaufplan / Flussdiagramm\n\n\n\n\n\n\n\nBeispiel:\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 33\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\n\n\nGrafische Darstellung als geschlossener Block\n\n Muss mit Startknoten      beginnen\n\n Muss mit Endknoten       enden\n\n\n\n\n\n\n\n\n\nAktionen: abgerundete Rechtecke\n\nFallunterscheidung: Raute mit Bedingung\n\nSchleife: Fallunterscheidung mit Rücksprung\n\nbed.?\n\nProgrammfluss: Kanten\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 34\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\n\n\nVerzweigungen werden durch Rauten dargestellt\n\n\n\n\n\n\n\nJa-Ausgang wird genommen, wenn Bedingung zutrifft\n\nNein-Ausgang wird genommen, wenn Bedingung nicht zutrifft\n\nBei Fallunterscheidungen entsprechend weitere Ausgänge\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 35\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\n• Bedingungsabfrage durch Verzweigung\n\n• Rücksprung an Schleifeneintritt durch Zusammenführung\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 36\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\nZählschleife:\n\nfor i = startwert to endwert step s\n\n    Schleifenrumpf ausführen\n\nFalls s<= -1 : \n\nrückwärts zählen\n\nFalls s==  0 : \n\nnicht sinnvoll\n\nFalls s>=  1 : \n\nvorwärts zählen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 37\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\n Aktivitäten lassen sich hierarchisch schachteln\n\n Eine Aktivität kann wieder als eine Menge von Detail-Aktivitäten (ggf. \n\ndargestellt in weiterem Aktivitätsdiagramm) aufgefasst werden\n\n Wichtig: Die Ein- und Ausgänge müssen aber dementsprechend \n\nübereinstimmen!\n\n Diese Methode spiegelt das „Divide and Conquer“ wieder\n\n Als Symbol wird ein Aktivitätssymbol mit zwei enthaltenen \n\nAktivitätssymbolen verwendet\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 38\n\n 3 - Programmentwurf      \n\nAktivitätsdiagramm\n\nDia-Portable\n\nAuf www.portableapps.com\n\n\n\n\n\n\n\n\n\nFreeware\n\nDrag‘n drop\n\nbeherrscht auch andere UML- \n\nDarstellungen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 39\n\n"

3 - Programmentwurf       Pseudocode:,3 - Programmentwurf      \n\nPseudocode:\n\n Pascal-ähnliche Notation:\n\nbegin BetragPruefen\n\nEingabe(a);\nEingabe(b);\nif a > b then\n\nAusgabe(a);\n\nelse\n\nend if\n\nAusgabe(b);\n\nend BetragPruefen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 41\n\n

4 – Erste Schritte      Kapitel 4 – Erste Schritte,4 – Erste Schritte     \n\nKapitel 4 – Erste Schritte\n\nEclipse + Java Development Kit (JDK)\n\n\n\n\n\n\n\n\n\nKommentare\n\nNamenskonventionen\n\nEin- und Ausgabe mit JAVA\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 43\n\n

4 - Erste Schritte Eclipse und JDK,4 - Erste Schritte\n\nEclipse und JDK\n\n1. Laden Sie sich das neueste Java JDK von Oracle herunter.\n\n(achten Sie darauf ob ihr System ein 32 oder 64 Bit System ist)\n\n2.\n\nInstallieren Sie das JDK\n\n3. Laden Sie sich Eclipse (oder Eclipse Portable) herunter:\n\nhttp://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/marsr\n\n4.\n\nInstallieren Sie sich Eclipse\n\n5. Starten Sie Eclipse\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 44\n\n

4 - Erste Schritte Ein erstes JAVA Projekt,"4 - Erste Schritte\n\nEin erstes JAVA Projekt\n\nRechte Mouse-Taste\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 45\n\n 4 - Erste Schritte\n\nEin erstes JAVA Projekt\n\nKlassennamen eintippen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 46\n\n 4 - Erste Schritte\n\nEin erstes JAVA Projekt\n\nDas erste Programm:\n\npublic class test{\n\n public static void main(String[] argc) // start of the main program\n\n  System.out.println(""Hello World! ""); // output of „Hello World!“\n\n }                                \n\n {\n\n}\n\nAchtung: JAVA unterscheidet Groß-/Kleinschreibung (=case sensitive)!!!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 47\n\n"

4 - Erste Schritte Kommentare,"4 - Erste Schritte\n\nKommentare\n\n\n\nmit // wird der Rest der Zeile auskommentiert\n\n    mit /* Kommentar */ wird alles zwischen /* und */ auskommentiert und vom \n\nCompiler nicht beachtet\n\n\n\nFür die Übung bitte über jedes Programm eine kurze Beschreibung, was es \n\nmacht und welche Funktionen enthalten sind und…\n\n …über jede Methode eine kurze Funktionsbeschreibung, was jeder \n\nÜbergabeparameter bedeutet und was der Rückgabewert bedeutet\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 48\n\n"

4 - Erste Schritte Kommentare - warum?,4 - Erste Schritte\n\nKommentare - warum?\n\n\n\nSoftware wird meist in Teams erstellt\n\n\n\nAndere müssen Ihren Code verstehen und nachvollziehen können\n\n um Fehler zu beheben\n\n um Ihre Programme weiter zu entwickeln\n\n\n\nSie selbst müssen auch nach längerer Zeit Ihren Code noch\n\n verstehen\n\n erweitern\n\n verbessern\n\n Debuggen\n\n\n\n60 – 70% aller Entwicklungsarbeiten und –kosten entstehen durch\n\nWartung und Weiterentwicklung!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 49\n\n

4 - Erste Schritte Kommentare (wie?),4 - Erste Schritte\n\nKommentare (wie?)\n\n\n\nJede Methode sollte in Zukunft auf Englisch dokumentiert werden \n\n(Beispiel: javadoc kompatible Dokumentation):\n\n/*************************************************************************\n\n @brief     Description:  generateThread\n\n            This function generates a thread.    \n\n @param     threadNum   : is of type integer and defines the \n\n                          Threadnumber...\n\n @return                : SUCCESS  = thread was generated\n\n                          FAILED   = thread couldn‘t be generated\n\n*************************************************************************/\n\nchar generateThread(int threadNum)\n\n{\n\n…\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 50\n\n

4 - Erste Schritte Modularisierung,"4 - Erste Schritte\n\nModularisierung\n\n\n\n\n\n\n\nJAVA bietet Klassen und Pakete zur Modularisierung des Quelltextes an\n\nMit Paketnamen lassen sich zusammengehörige Klassen zu einer Einheit \n\nzusammenfassen \n\nMit unterschiedlichen Paketnamen können Klassen, die eigentlich wegen \n\neiner Namenskollision nicht kombinierbar wären, trotzdem  in einem \n\nProgramm genutzt werden \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 51\n\n"

4 - Erste Schritte Modularisierung (Definition von Paketen),"4 - Erste Schritte\n\nModularisierung (Definition von Paketen)\n\n\n\nJede Klasse kann mit Hilfe einer package-Anweisung einem Paket \nzugeordnet werden\n\n Wenn Pakete hierarchisch geschachtelt sind, bleiben über- und \n\nuntergeordnete Pakete trotzdem logisch unabhängig voneinander\n\nBeispiel:\n\npackage de.companyXY.graphics\n\npublic class Screen{\n\n}\n\nHier wird die Klasse Screen auf das Verzeichnis ./de/companyXY/graphics \n\nrelativ zum Projektverzeichnis abgebildet.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 52\n\n"

4 - Erste Schritte Modularisierung (Zugriff auf Pakete),"4 - Erste Schritte\n\nModularisierung (Zugriff auf Pakete)\n\n\n\n\n\nAuf Klassen im selben Paket kann direkt zugegriffen werden\n\nKlassen in anderen Paketen müssen mit Hilfe des Punktoperators \n\nangesprochen werden:\n\nde.companyXY.graphics.Screen myScreen = new Screen();\n\n\n\nMit der import-Anweisung wird diese Schreibweise vereinfachen:\n\n\n\nOder wie von SUN empfohlen, nur die eigentliche Klasse einbinden:\n\nimport de.companyXY.graphics.*;\n\nScreen myScreen = new Screen();\n\nimport de.companyXY.graphics.Screen;\n\nScreen myScreen= new Screen();\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 53\n\n"

4 - Erste Schritte Namenskonventionen,"4 - Erste Schritte\n\nNamenskonventionen\n\nSprache\n\n\n\nKommentare und Variablen bitte auf Englisch\n\nVariablen sinnvoll benennen\n\nselbsterklärend\n\nnicht i1 oder k19\n\nnicht übermäßig lang (Tipparbeit!)\n\nBeispiel: maximum oder max statt m\n\nc für einen char-Wert\n\nd, e, f für einen double-Wert\n\ni, j, k für int-Werte\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbweichung: Schleifenzähler + Hilfsvariablen kurz und prägnant, z.B.:\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 54\n\n 4 - Erste Schritte\n\nNamenskonventionen\n\nNamenskonventionen\n\nwerden von der Programmiersprache vorgegeben\n\nhaben sich als vorteilhaft erwiesen\n\nsollen die Lesbarkeit von fremdem Codes erhöhen\n\nwerden z.B. in mitgelieferten Funktionsbibliotheken eingehalten\n\nsind einzuhalten in Übungen und Klausur!\n\nLokale Variablennamen\n\nbeginnen mit Kleinbuchstabe\n\nweiter mit Kleinbuchstaben\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbei neuem Wortstamm einen Großbuchstaben mittendrin, \n\nz.B. numberProfessors\n\nKeine Unterstriche (_) mehr \uf0e0 veraltet,\n\nz.B.: numberProfessors statt  number_professors\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 55\n\n"

4 - Erste Schritte Ein- und Ausgabe mit JAVA,"4 - Erste Schritte\n\nEin- und Ausgabe mit JAVA\n\n\n\nDie „print“ Anweisung\n\npublic class Test{\n\n public static void main(String[] args)\n\n  System.out.print(""Ganze Zahl = "" + 5);// kein Zeilenumbruch\n\n  System.out.println(""..."");// mit Zeilenumbruch\n\n {\n\n }\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 56\n\n"

4 - Erste Schritte ,4 - Erste Schritte\n\n\n\nEingaben können in Java mit Hilfe der Scanner Klasse gemacht werden:\n\nimport java.util.*;\n\npublic class MyClass {\n\npublic static void main(String[] args){\n\nScanner sc = new Scanner(System.in);\n\n// Input functions for different datatypes\n\nint i    = sc.nextInt();\n\nfloat f  = sc.nextFloat();\n\ndouble d = sc.nextDouble();\n\nString s = sc.nextLine();\n\n}\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 57\n\n

4 - Erste Schritte Und ein Beispielprogramm…,"4 - Erste Schritte\n\nUnd ein Beispielprogramm…\n\nimport java.util.*;\n\npublic class MyClass{\n\n  public static void main(String[] argc){\n\n   Scanner sc = new Scanner(System.in);\n\n      System.out.print(""Bitte Länge in Inch eingeben:"")\n\n      double length = sc.nextDouble();\n\n      System.out.println(""\\n entspricht:"" + length*2.5 + "" cm""); \n\n  }\n\n}\n\n  \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 58\n\n"

5 - Die Programmiersprache JAVA Kapitel 5 – Die Programmiersprache JAVA,5 - Die Programmiersprache JAVA\n\nKapitel 5 – Die Programmiersprache JAVA\n\n\n\n\n\n\n\n\n\n\n\nSchlüsselwörter\n\nAusdrücke\n\nAnweisungen\n\nToken\n\nLiterale\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 60\n\n

5 - Die Programmiersprache JAVA Schlüsselwörter:,5 - Die Programmiersprache JAVA\n\nSchlüsselwörter:\n\nabstract\n\ncontinue\n\ngoto\n\npackage\n\nthis\n\nassert\n\ndefault\n\nif\n\nprivate\n\nthrow\n\nboolean\n\ndo\n\nimplements\n\nprotected\n\nthrows\n\nbreak\n\ndouble\n\nimport\n\npublic\n\ntransient\n\nbyte\n\ncase\n\ncatch\n\nchar\n\nclass\n\nconst\n\nelse\n\ninstanceof\n\nreturn\n\nextends\n\nint\n\nfinal\n\ninterface\n\nfinally\n\nlong\n\nshort\n\nstatic\n\nsuper\n\ntry\n\nvoid\n\nvolatile\n\nwhile\n\nfloat\n\nfor\n\nnative\n\nswitch\n\nnew\n\nsynchronized\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 61\n\n

5 - Die Programmiersprache JAVA Ausdrücke:,"5 - Die Programmiersprache JAVA\n\nAusdrücke:\n\n liefern einen Wert als Ergebnis\n\n haben bestimmten Typ (z.B. int, char)\n\nz.B.\n\n Literale (Wertkonstanten), z.B. 5.0\n\n Variablen, z.B. x\n\n Arithmetische Ausdrücke, z.B.: 5*x+3*y\n\n\n\nliefern ganze Zahl oder Fließkommazahl\n\n Boolesche Ausdrücke, z.B.: (x && y) || z\n\n\n\nliefern true (in C: 1) oder false (in C: 0)\n\n Vergleichsausdrücke, z.B.: x>3\n\n\n\nliefern true (in C: 1) oder false (in C: 0)\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 62\n\n"

5 - Die Programmiersprache JAVA Anweisungen,"5 - Die Programmiersprache JAVA\n\nAnweisungen\n\ndefinieren Programmablauf\n\nenthalten / nutzen Ausdrücke\n\nz.B.\n\nZuweisungen\n\nFolgen von  Anweisungen\n\nProzedur-, Funktions-, Methoden-Aufrufe\n\nBedingte Abfragen\n\nSchleifen\n\netc.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 63\n\n"

5 - Die Programmiersprache JAVA Token,"5 - Die Programmiersprache JAVA\n\nToken\n\n\n\nzusammenhängendes Wort gebildet aus einem Alphabet\n\n Alphabet: z.B. Buchstaben, aber auch: Zahlen, _\n\n\n\ngetrennt vom nächsten Token durch Trennzeichen\n\n Whitespaces: Leerzeichen, Zeilenumbruch, Tabulator\n\n Weitere mögliche Trennzeichen:\n\n Klammern\n\n Komma\n\n Semikolon\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 64\n\n"

5 - Die Programmiersprache JAVA Literale,"5 - Die Programmiersprache JAVA\n\nLiterale\n\n\n\nkonkrete Angabe eines Zahl-, Zeichen- oder Zeichenkettenwertes im \n\nQuellcode z.B. “Hello World 1234“\n\n Wertkonstante z.B. 6.4564\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 65\n\n"

6 - Variablen und Datentypen Kapitel 6 – Variablen und Datentypen,6 - Variablen und Datentypen\n\nKapitel 6 – Variablen und Datentypen\n\nElementare Datentypen\n\n\n\n\n\n\n\n\n\n\n\nVariablen\n\nKonstanten\n\nStrings\n\nArrays\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 67\n\n

6 - Variablen und Datentypen Elementare Datentypen,"6 - Variablen und Datentypen\n\nElementare Datentypen\n\nWertebereich\n\nBeschreibung\n\nDatentyp\n\n boolean\n\nbyte\n\nshort\n\n char\n\nint\n\nlong\n\nfloat\n\n  true, false\n\n-128..127\n\n-32768 .. 32767\n\n-32768 .. 32767\n\n-2147483648 .. \n2147483647\n\n zweiwertig\n\nganzzahlig \n\nganzzahlig\n\nganzzahlig/ Buchstaben\n\nganzzahlig\n\n-9223372036854775808 .. \n9223372036854775807\n\nganzzahlig\n\n+-1.40239846 10^-45 ..    \n+-3.40282347 10^38\n\nFließkommazahl mit etwa 7 \nStellen Genauigkeit\n\ndouble\n\n+-4.9 10^-324 ..\n+-1.79 10^308\n\nFließkommazahl mit etwa 15 \nStellen genauigkeit\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 68\n\n"

6 - Variablen und Datentypen Variablen,"6 - Variablen und Datentypen\n\nVariablen\n\n Platzhalter eines definierten Datentyps. \n\n Muss vor dem Gebrauch deklariert werden\n\n Muss vor Gebrauch initialisiert werden\n\n Ist nur innerhalb des Blocks { }, in der sie deklariert ist, gültig!\n\nBeispiele:\n\nfloat zahl1;\n\nint   zahl2 = 5, zahl3 = 7;\n\ndouble dPi = 3.1415927;\n\nfloat fPi = 3.1415927f;\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 69\n\n"

6 - Variablen und Datentypen ● Konstanten werden mit vorangestelltem Schlüsselwort final deklariert ,"6 - Variablen und Datentypen\n\n Konstanten werden mit vorangestelltem Schlüsselwort final deklariert \n\n Sie müssen vor dem Gebrauch deklariert werden\n\n Bei der Deklaration wird i.Allg. ein Datentyp festgelegt und ein Wert \n\nKonstanten\n\nübergeben.\n\nBeispiele:\n\nfinal int   zahl2 = 5, zahl3 = 7;\n\nfinal double dPi = 3.1415927;\n\nfinal float fPi = 3.1415927f;\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 70\n\n"

6 - Variablen und Datentypen Strings,"6 - Variablen und Datentypen\n\nStrings\n\n String-Literal \n\n Es beginnt und endet mit ""Anführungszeichen"".\n\n Dazwischen dürfen beliebig viele Zeichen (auch Escape-Codes) stehen.\n\n Beispiele für String-Literale:\n\n""Hallo zusammen!""\n\n\n\n\n\n""Hallo Java-Programmierer!\\nWie geht\'s?\\n""\n\n Anwendung z.B.:\n\n System.out.print(""Hallo Java-Programmierer!\\nWie geht\'s?\\n"");\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 71\n\n 6 - Variablen und Datentypen\n\nStrings\n\nz.B. \n\n• Strings können Zeichenketten beliebiger Länge enthalten\n\n• Zeichen sind als Unicode in jeweils 2 Byte gespeichert\n   \n\nString vorname = ""Dieter"";\n\nint laenge = vorname.length();\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 72\n\n"

7 - Arithmetische Ausdrücke Kapitel 7 – Arithmetische Ausdrücke,7 - Arithmetische Ausdrücke\n\nKapitel 7 – Arithmetische Ausdrücke\n\nAuswertungsreihenfolge\n\nRechnen mit unterschiedlichen Datentypen\n\n\n\n\n\n\n\n\n\nOperatoren\n\nBitweise Operatoren\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 74\n\n

7 - Arithmetische Ausdrücke Auswertungsreihenfolge,7 - Arithmetische Ausdrücke\n\nAuswertungsreihenfolge\n\n Ein berechnender Ausdruck wird von links nach rechts ausgewertet\n\n Klammern werden von innen nach außen ausgewertet\n\n Zuweisungen werden von rechts nach links ausgewertet.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nPage 75\n\n

7 - Arithmetische Ausdrücke Rechnen mit unterschiedlichen Datentypen,"7 - Arithmetische Ausdrücke\n\nRechnen mit unterschiedlichen Datentypen\n\nDatentypen werden automatisch einander angeglichen:\n\nBeispiel, wie die Virtuelle Maschine die erste Zeile interpretiert:\n\ndouble d = 3.0f + 4;\n\ndouble d = 3.0f + 4.0f;\n\ndouble d = 7.0f;\n\ndouble d = 7.0d;\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 76\n\n 7 - Arithmetische Ausdrücke\n\nRechnen mit unterschiedlichen Datentypen\n\n Wenn Zieldatentyp „größer“ bzw. genauer als Datentyp des Wertes\n\n Automatische Datentypumwandlung\n\n            boolean→byte→char/short → int → long → float → double\n\n          \n\n Wenn Zieldatentyp „kleiner“ bzw. ungenauer als Datentyp des Wertes\n\n Datentypumwandlung sollte durch Type Cast erzwungen werden, da sonst \n\nFehler entstehen können.\n\n Compiler merkt das nicht immer!\n\n Schreibweise:\n\n(<Zieldatentyp>) <Wert> \n\nshort sh;\n\nlong l = 18;\n\nsh = (short) l;\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 77\n\n 7 - Arithmetische Ausdrücke\n\nRechnen mit unterschiedlichen Datentypen\n\n Rundungsfehler:\n\ndouble  \uf0ae float: nächste darstellbare Zahl\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndouble  \uf0ae long, int, short, char oder byte: Nachkommastellen abschneiden\n\n                   + abschneiden überzähliger vorderer Bits\n\nfloat \n\n\uf0ae long, int, short, char oder byte: Nachkommastellen abschneiden\n\n                   + abschneiden überzähliger vorderer Bits\n\nRechenfehler\n\nUrsache: Abschneiden überzähliger vorderer Bits\n\nlong \n\n\uf0ae int, short, char oder byte:vordere 32, 48 oder 56 Bits abschneiden \n\nint \n\n       \uf0ae short oder char: vordere 16 oder 24 Bits abschneiden\n\nshort\n\n\uf0ae byte: vordere 8 Bits abschneiden\n\nBeispiele:\n\n(int)3.1415 \uf0ae 3\n\n(byte)120 \uf0ae 120\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 78\n\n"

7 - Arithmetische Ausdrücke Operatoren (Auswertungsreihenfolge),7 - Arithmetische Ausdrücke\n\nOperatoren (Auswertungsreihenfolge)\n\nOperatorsymbol\n\nPriorität\n\nBezeichnung\n\nKlammern\n\nNegation Inkrement Dekrement\n\nArithmetische Operatoren\n\nShift Operatoren\n\nVergleichsoperatoren\n\nBitweise Operatoren\n\nLogische Operatoren\n\n() []\n\n- ! ~ ++ --\n\n* / %\n\n+ -\n\n<< >> >>>\n\n> >= < <=\n\n== !=\n\n&\n\n^\n\n|\n\n&&\n\n||\n\n13\n\n12\n\n11\n\n10\n\n9\n\n8\n\n7\n\n6\n\n5\n\n4\n\n3\n\n2\n\n1\n\nZuweisungsoperator\n\n= += -= *= /= %= >>= <<= &= ^= |= \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 79\n\n

7 - Arithmetische Ausdrücke Operatoren,"7 - Arithmetische Ausdrücke\n\nOperatoren\n\n\n\n\n\nPrä- und Postinkrement gibt es auch in der Programmiersprache C. \n\nDer  Postinkrement  in Java verhält sich jedoch z.T. anders als in C:\n\n Wenn das Ergebnis eines Postinkrements der Variablen zugewiesen wird, die \n\ninkrementiert wird, so wird der Postinkrement ignoriert. \n\n\n\nDas ist in etwa so, als würde die Zuweisung erst in eine Hilfsvariable abgelegt \n\nwerden, um sie dann der Variablen selbst zuzuweisen.\n\nBeispiel in JAVA:\n\nint a = 0;\n\na = a++;    // a == 0\n\na = ++a;    // a == 1\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\n 7 - Arithmetische Ausdrücke\n\nOperatoren\n\nSinnvolle Verwendung von Inkrement und Dekrement\n\nInkrement und Dekrement in komplexen Ausdrücken\n\nZählschleifen\n\nArrayindizierung\n\n\n\n\n\n\n\n\n\nerschwert Lesen von Programmen\n\nerschwert Fehlersuche\n\nvorsichtig und sparsam einsetzen!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 84\n\n"

7 - Arithmetische Ausdrücke Weitere abkürzende Schreibweisen der Zuweisung,"7 - Arithmetische Ausdrücke\n\nWeitere abkürzende Schreibweisen der Zuweisung\n\nInkrement-und Dekrement-Operator ++ und --\n\na = a + 1;   oder auch   a += 1;\n\nkürzer geschrieben:\n\nOperatoren\n\n\n\n\n\nBeispiel:\n\noder\n\na++;\n\n++a;\n\nPräfix-Operatoren: Stehen vor Variable, z.B: ++a\n\nPostfix-Operatoren: Stehen nach Variable, z.B: a--\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 81\n\n"

7 - Arithmetische Ausdrücke Unterschied zwischen Präfix- und Postfix-Operatoren:,"7 - Arithmetische Ausdrücke\n\nUnterschied zwischen Präfix- und Postfix-Operatoren:\n\nerst inkrementieren / dekrementieren\n\ndann mit neuem Wert im Ausdruck weiterrechnen\n\nOperatoren\n\nPräfix-Operator\n\nPostfix-Operator\n\n\n\n\n\n\n\n\n\nmit altem Wert im Ausdruck weiterrechnen\n\ndann erst dekrementieren / inkrementieren\n\nBeispiel:\n\nint a, b = 1;\n\na = b++;    // b == 2,  a == 1\n\na = ++b;    // b == 3,  a == 3\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 82\n\n"

7 - Arithmetische Ausdrücke Bitweise Operatoren,7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nOperator\n\nBeschreibung\n\nbitweise oder  (OR)\n\nbitweise und (AND)\n\nbitweise nicht (NOT)\n\nAusschließendes oder (XOR)\n\nlinks Verschiebung (shift left)\n\n|\n\n&\n\n~\n\n^\n\n<<\n\n>>\n\n >>>\n\nrechts Verschiebung (shift right) mit Vorzeichen Erweiterung\n\n Rechts Verschiebung (shift right) ohne Vorzeichen Erweiterung\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 85\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nBitweise ODER (OR):\n\nA\n\n0\n\n0\n\n1\n\n1\n\nB\n\n0\n\n1\n\n0\n\n1\n\nA | B\n\n0\n\n1\n\n1\n\n1\n\nBeispiel:\n\n  0 1 0 0 0 1 0 1 0 0 1 bin = 553dez \n\n| 1 0 0 1 0 1 0 0 1 0 0 bin = 1188dez\n\n= 1 1 0 1 0 1 0 1 1 0 1 bin = 1709dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 86\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nBitweise UND (AND):\n\nA\n\n0\n\n0\n\n1\n\n1\n\nB\n\n0\n\n1\n\n0\n\n1\n\nA & B\n\n0\n\n0\n\n0\n\n1\n\nBeispiel:\n\n  0 1 0 0 0 1 0 1 0 0 1 bin = 553dez \n\n& 1 0 0 1 0 1 0 0 1 0 0 bin = 1188dez\n\n= 0 0 0 0 0 1 0 0 0 0 0 bin = 32dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 87\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nBitweise NICHT (NOT):\n\nA\n\n0\n\n1\n\n~A\n\n1\n\n0\n\nBeispiel:\n\n~ 0 1 0 0 0 1 0 1 0 0 1 bin = 553dez \n\n= 1 0 1 1 1 0 1 0 1 1 0 bin = 1494dez\n\nBitbreite ist entscheidend für das Ergebnis\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 88\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nBitweise ausschließendes ODER (XOR):\n\nA\n\n0\n\n0\n\n1\n\n1\n\nB\n\n0\n\n1\n\n0\n\n1\n\nA ^ B\n\n0\n\n1\n\n1\n\n0\n\nBeispiel:\n\n  0 1 0 0 0 1 0 1 0 0 1 bin = 553dez \n\n^ 1 0 0 1 0 1 0 0 1 0 0 bin = 1188dez\n\n= 1 1 0 1 0 0 0 1 1 0 1 bin = 1677dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 89\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nVerschiebung nach links (SHIFT LEFT):\n\nNach links verschieben um x Stellen entspricht der Multiplikaton mit 2x\n\nBeispiel:\n\n0 0 1 0 0 0 1 0 1 0 0 1 bin << 1    =   553dez * 2\n\n0 1 0 0 0 1 0 1 0 0 1 0 bin             =   1106dez\n\n0 0 1 0 0 0 1 0 1 0 0 1 bin << 2    =   553dez * 4\n\n1 0 0 0 1 0 1 0 0 1 0 0 bin             =   2212dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 90\n\n 7 - Arithmetische Ausdrücke\n\nBitweise Operatoren\n\nVerschiebung nach rechts (SHIFT RIGHT):\n\nNach rechts verschieben um x Stellen entspricht der Integer-Division durch 2x\n\nBeispiel:\n\n0 0 1 0 0 0 1 0 1 0 0 1 bin >> 1    =   553dez / 2\n\n0 0 0 1 0 0 0 1 0 1 0 0 bin             =   276dez\n\n0 0 1 0 0 0 1 0 1 0 0 1 bin >> 2    =   553dez / 4\n\n0 0 0 0 1 0 0 0 1 0 1 0 bin             =   138dez\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 91\n\n

8 - Anweisungen Kapitel 8 – Anweisungen,8 - Anweisungen\n\nKapitel 8 – Anweisungen\n\n\n\n\n\n\n\n\n\nEin-Ausgabe Anweisungen\n\nSchleifen\n\nFallunterscheidungen\n\nSprungbefehle\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 93\n\n

8 - Anweisungen Ein-Ausgabe Anweisung (mit Hilfsfunktionen),"8 - Anweisungen\n\nEin-Ausgabe Anweisung (mit Hilfsfunktionen)\n\nimport java.io.*\n\nimport java.util.*\n\npublic class MyClass{\n\n public static void main(String[] arg)\n\n  Scanner sc = new Scanner(System.in);\n\n  int zahl = sc.nextInt();    \n\n  double kommaZahl = sc.nextDouble();       \n\n  String text = sc.nextLine(); \n\n  System.out.println(""integer zahl    = "" + zahl);\n\n  System.out.println(""float kommaZahl = "" + kommaZahl);\n\n  System.out.println(""string text     = "" + text);\n\n {\n\n }\n\n} \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 94\n\n"

8 - Anweisungen Schleifen (for),"8 - Anweisungen\n\nSchleifen (for)\n\nMöchte man einen oder mehrere Befehle wiederholen, so kann man die for- \n\nSchleife nutzen. Sie besteht aus drei durch Semikolon getrennten Bereichen: \n\n Die Initialisierung legt den Startwert des Zählers fest) z.B.: int i=0  \n\n Die Zählbedingung, legt fest bis zu welchem Wert gezählt wird z.B.: i < 100\n\n Die Änderung des Zählwertes für jeden Durchlauf z.B.: i = i + 2\n\n for  ( Initialisierung ; Zählbedingung ; Änderung des Zählwertes){\n\n      // Zu wiederholender Anweisungsblock \n\n }\n\n \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 95\n\n 8 - Anweisungen\n\nSchleifen (for)\n\nWird die Zählbedingung leer gelassen, bedeutet das, dass sie immer erfüllt ist und \n\neine Endlosschleife entsteht, die nur durch eine break; Anweisung im \n\nSchleifenrumpf abgebrochen werden kann.\n\nBeispiele Endlosschleife:\n\nfor (;;){ \n\nBeispiele Zähler von 0 bis 99:\n\nfor (int zaehler = 0; zaehler < 100; zaehler++){ \n\nSystem.out.println(""zaehler hat den Wert:""+zaehler); \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 96\n\n}\n\n}\n\n \n\n"

8 - Anweisungen Schleifen (For each),"8 - Anweisungen\n\nSchleifen (For each)\n\nDie For each Schleife ermöglicht es alle Elemente eines Arrays zu durchlaufen. \n\nDabei nimmt die Variable die Werte der Array-Elemente an.\n\nint[] myArray = new int[]{5, 7, 3, 2};\n\nfor( int k: myArray ){\n\nSystem.out.println(""k = ""+k);\n\n}\n\n \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 97\n\n"

8 - Anweisungen Schleifen (while),"8 - Anweisungen\n\nSchleifen (while)\n\n„while“  bedeutet „solange“, darauf folgt die Bedingung in runden Klammern, \n\ndarauf der zu wiederholende Anweisungsblock in geschweiften Klammern.\n\nwhile( Bedingung ){   // kopfgesteuerte Schleife\n\n      // zu wiederholender Anweisungsblock \n\n}\n\n}\n\nBeispiel:\n\nzaehler = 0;\n\nwhile (zaehler < 100){\n\n    zaehler ++; \n\n System.out.println(""zaehler hat den Wert:""+zaehler);\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 98\n\n"

8 - Anweisungen Schleifen (do-while),"8 - Anweisungen\n\nSchleifen (do-while)\n\nDie „do-while“ Schleife beginnt mit dem Schlüsselwort „do“, wonach direkt \n\nder zu wiederholende Anweisungsblock kommt. Erst danach wird mit „while“ \n\ndie Bedingung in runden Klammern angekündigt.\n\nDo{\n\n   // zu wiederholender Anweisungsblock\n\n}while( Bedingung )\n\nBeispiel:\n\nzaehler = 0;\n\ndo{\n\n   zaehler++;\n\n}while(zaehler<100);\n\nSystem.out.println(""Zaehler hat den Wert:""+zaehler);\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 99\n\n"

8 - Anweisungen ●,"8 - Anweisungen\n\n\n\nFallunterscheidungen (if-else)\n\nMit der if-else Anweisung ist es möglich, eine Wenn-Dann-Beziehung\n\n auszudrücken. Nach einem „if“ kommt die Bedingung in runden\n\n Klammern. Ist sie erfüllt, so wird der darauf folgende Anweisungsblock\n\n ausgeführt, ansonsten wird ein optionaler else-Block ausgeführt.\n\nint variable; \n\nif (variable==1){ \n\nelse{ \n\n} \n\nSystem.out.println(""variable ist gleich 1\\n""); \n\n} // der nachfolgende „else“ Teil ist nicht notwendig\n\nSystem.out.println(""variable ist ungleich 1\\n""); \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 100\n\n"

8 - Anweisungen Fallunterscheidungen (switch-case),"8 - Anweisungen\n\nFallunterscheidungen (switch-case)\n\nDie switch-case Anweisung bietet eine schnelle Möglichkeit, viele Vergleiche in einer \n\nAnweisung auszuwerten:\n\nswitch(variable){ \n\ncase 1: /* Die Variable ist gleich 1 */ break; \n\ncase 2: /* Die Variable ist gleich 2 */ break; \n\ndefault:/* die Variable ist ungleich 1 und ungleich 2*/  \n\n} \n\nFallunterscheidungen (? Operator)\n\nDer Fragezeichenoperator ? ermöglicht eine sehr verkürzte Schreibweise einer \n\nFallunterscheidung :       Bedingung ? Anweisung1 : Anweisung2\n\nIst die Bedingung erfüllt, so wird Anweisung1 ausgeführt, sonst Anweisung2.\n\n str = (A > B ? ""A ist größer"" : ""B ist größer"");\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 101\n\n"

"9 – Arrays, Enumerationen Kapitel 9 – Arrays, Enumerationen","9 – Arrays, Enumerationen\n\nKapitel 9 – Arrays, Enumerationen\n\n\n\n\n\n\n\n\n\nArrays (eindimensional)\n\nArrays (mehrdimensional)\n\nArrays (mit Arrays als Komponenten) \n\nEnumerationen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 103\n\n"

"9 – Arrays, Enumerationen Arrays (eindimensional)","9 – Arrays, Enumerationen\n\nArrays (eindimensional)\n\n Ein Array (oder ein Feld) hat eine Länge, die bei seiner Definition \n\nfestgelegt wird\n\n Auf die verschiedenen Elemente eines Arrays kann mittels Indizierung in \n\nbeliebiger Reihenfolge zugegriffen werden\n\n\n\nIn der Programmiersprache JAVA beginnen die Indizes immer mit 0\n\n2\n\n1\n\nArray:\n\n1. Wert\n\n2. Wert\n\n3. Wert\n\n4. Wert\n\n5. Wert\n\nn. Wert\n\nzahlen:\n\n12\n\n43\n\n23\n\n43\n\n...\n\n...\n\n...\n\n33\n\nn-1\n\nIndex:\n\n0\n\n2\n\n3\n\n4\n\nBeispiel für den Zugriff:\n\nzahlen[2]    == 43\nzahlen[n-1] == 33\n\nzahlen[n]    == 1 !!! Fehler!!!!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 104\n\n 9 – Arrays, Enumerationen\n\nArrays (eindimensional)\n\n Arrays sind Variablen, werden also wie diese mittels einer Definition angelegt:\n\n Syntax: <Datentyp> <variablenname> = new <Datentyp>[groesse]\n\n Beispiele:\n\n\n\n\n\n\n\nint quadrate[] = new int[30]; // legt ein Array aus 30 Integer Werten an\n\nfloat noten[] = new float[40];   // legt ein Array aus 40 Float Werten  an\n\ndouble feld[] = {1.1, 2.2, 3.3};   // legt ein Array aus 3 Double Werten an\n\n Arraylänge nachträglich nicht mehr änderbar!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 105\n\n"

"9 – Arrays, Enumerationen Arrays (mehrdimensional)","9 – Arrays, Enumerationen\n\nArrays (mehrdimensional)\n\n Man kann in Java auch mehrdimensionale Felder anlegen.\n\n Streng genommen sind das Felder mit Komponenten eines Feldtyps\n\n float matrix[][] = new float [3][]; legt beispielsweise ein Array an, bei \ndem nur die erste Komponente auf 3 festgelegt wird. Folgendes Beispiel zeigt, wie \n\ndie 2. Komponente auf 5 festgesetzt wird:\n\nfloat matrix[][] = new float [3][];\n\nfor (int i=0;i<3;i++)\n\n     matrix[i] = new float[5];\n\n Dies ist gleichbedeutend mit\n\nfloat matrix[][] = new float[3][5];\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 106\n\n"

"9 – Arrays, Enumerationen  Es ist zwar erlaubt, die eckigen Klammern auch vor dem Variablennamen zu ","9 – Arrays, Enumerationen\n\n Es ist zwar erlaubt, die eckigen Klammern auch vor dem Variablennamen zu \n\nArrays (mehrdimensional)\n\nsetzen:\n\nint[] var1, var2[], var3[][];\n\n Dies ist jedoch gleichbedeutend mit:\n\nint var1[], var2[][], var3[][][];\n\nwas zu Missverständnissen führen kann.\n\nAlso BITTE Arrays immer mit Klammern nach dem Variablennamen definieren!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 107\n\n"

"9 – Arrays, Enumerationen Enumerations","9 – Arrays, Enumerationen\n\nEnumerations\n\n Mit Hilfe der Enumeration können in Java fortlaufende Konstanten definiert werden:  \n\npublic enum wochentag{MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, \n\nFREITAG, SAMSTAG, SONNTAG};\n\nBenutzt wird das Ganze z.B. folgendermaßen:\n\npublic static void main(String[] args)\n\n wochentag tag;\n\n tag = wochentag.MONTAG;\n\n if (tag == wochentag.MONTAG){\n\n    System.out.println(""Es ist Montag"");\n\n{\n\n }\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 108\n\n"

10 – Funktionen/ Methoden Kapitel 10 – Funktionen/ Methoden ,10 – Funktionen/ Methoden\n\nKapitel 10 – Funktionen/ Methoden \n\n\n\n\n\n\n\nMethodendeklaration\n\nMethodenaufruf\n\nDie return-Anweisung\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 110\n\n

10 – Funktionen/ Methoden JAVA Methoden können nur innerhalb von Klassen deklariert werden.,"10 – Funktionen/ Methoden\n\nJAVA Methoden können nur innerhalb von Klassen deklariert werden.\n\n– Optionalen Modifizierern, wie public, abstract, final usw., die spezielle \n\nMethodendeklaration\n\n\n\n\n\nSie bestehen aus:\n\nAttribute der Methode festlegen\n\nDem Typ des Rückgabewertes\n\nEinem Methodennamen\n\nEiner Liste der Methodenparameter mit vorangestelltem Typ\n\nEiner optionalen throws Klausel, die anzeigt, welche Ausnahmen durch \n\neinen Methodenaufruf ausgeworfen werden können\n\nDem Methodenrumpf, der in { } eingeschlossen die Anweisungen enthält, \n\ndie beim Methodenaufruf ausgeführt werden.\n\n–\n\n–\n\n–\n\n–\n\n–\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 111\n\n"

10 – Funktionen/ Methoden Methodenaufruf,"10 – Funktionen/ Methoden\n\nMethodenaufruf\n\n\n\n\n\n\n\n\n\nEin Methodenaufruf ist ein elementarer Ausdruck\n\nDurch Abschluss mit ; wird der Ausdruck zur Anweisung\n\nDie im Funktionskopf definierten Parameter, werden bei jedem Aufruf mit den \n\nübergebenen Variablen initialisiert ,bevor der Funktionsrumpf ausgeführt wird.\n\nDie im Funktionskopf definierten Parameter sind in der gesamten Funktion gültig \n\nund dürfen nicht durch lokale Variablen verdeckt werden.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 112\n\n"

10 – Funktionen/ Methoden Methoden Aufruf (Basis- und Referenz-Typ),"10 – Funktionen/ Methoden\n\nMethoden Aufruf (Basis- und Referenz-Typ)\n\n Wird eine Variable eines Basisdatentyps übergeben, so wird \n\ninnerhalb der Funktion auf einer Kopie dieser Variablen gearbeitet, \n\ndie nach Rücksprung aus der Funktion keine Auswirkung auf die \n\nübergebene Variable hat.\n\n Wird eine Variable eines Referenztyps übergeben, so kann man \n\ndessen Wert/ Werte innerhalb der Funktion so verändern, dass er \n\nauch nach Rücksprung aus der Funktion verändert bleibt.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 113\n\n"

10 – Funktionen/ Methoden Beispiel für Übergabe als Basistyp:,"10 – Funktionen/ Methoden\n\nBeispiel für Übergabe als Basistyp:\n\nvoid init(int var) // Variable ist eine Kopie von a auf dem Stack\n\n var = 5; // variable is only changed on the stack\n\n          // leaving the function, the variable is lost\n\n}                            \n\npublic static void main(String[] argc)\n\n int a=3;\n\n init(a); // contents of a is given to the function init()\n\n System.out.println(""Der Wert von a ist "" + a); // output: 3 \n\n{\n\n{\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 114\n\n"

10 – Funktionen/ Methoden Beispiel für Übergabe als Referenztyp:,"10 – Funktionen/ Methoden\n\nBeispiel für Übergabe als Referenztyp:\n\npublic class MyInteger{\n\n public int value;\n\npublic class MyClass{ \n\n}\n\n }\n\n}\n\n void init(MyInteger var){ // variable is of reference type\n\n      var.value = 5;       // variable is changed\n\n }                            \n\n public static void main(String[] argc){\n\n  MyInteger a = new MyInteger();\n\n  a.value = 3;\n\n  init(a); \n\n  System.out.println(""Der Wert von a ist "" + a.value); // output: 5 \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 115\n\n"

10 – Funktionen/ Methoden Die return Anweisung,"10 – Funktionen/ Methoden\n\nDie return Anweisung\n\n\n\n\n\n\n\n\n\nDie return-Anweisung beendet den Aufruf einer Methode\n\nFalls der Ergebnistyp einer Methode „void“ ist, kann return; geschrieben \nwerden\n\nSonst wird mit return Ausdruck; ein Wert des Rückgabetyps zurückgegeben\n\nSteht das return Ausdruck; innerhalb einer bedingten Verzweigung, so muss \nbei Nichterfüllung sichergestellt werden, dass ein anderes return Ausdruck; \ninnerhalb der Funktion aufgerufen wird.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 116\n\n"

11 – Rekursion Kapitel 11 – Rekursion,11 – Rekursion\n\nKapitel 11 – Rekursion\n\n\n\n\n\n\n\n\n\nDefinition\n\nRealisierung\n\nBeispiel: Iterative Suche\n\nBeispiel: 3D - Gebirge\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 118\n\n

11 – Rekursion Definition,"11 – Rekursion\n\nDefinition\n\n\n\nEin Funktionsaufruf ist rekursiv, wenn die aufgerufene Funktion innerhalb \n\nihres Ablaufs mindestens noch einmal aufgerufen wird.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 119\n\n"

11 – Rekursion Realisierung,"11 – Rekursion\n\nRealisierung\n\n\n\n\n\n\n\nTypischerweise beinhaltet eine rekursive Funktion eine Fallunterscheidung\n\nHier wird entschieden, ob mit Rekursion (Selbstaufrufen) fortgefahren wird\n\n...oder, ob die Funktion in den aufrufenden Kontext zurückkehrt\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 120\n\n"

11 – Rekursion Iterative Suche,"11 – Rekursion\n\nIterative Suche\n\nsuchen.\n\n\n\nDie folgende Methode sollte im sortierten Array number[100], die Zahl 33 \n\npublic int search(int number[],int min, int max){\n\n       int index = (max-min)/2;\n\n       if (number[index]>33){\n\n          max = index;\n\n          return search(number,min,max);\n\n       }\n\n       else if (number[index]<33){\n\n          min = index;\n\n          return search(number,min,max);\n\n   }\n\n       else{\n\n       }\n\n}\n\n          return index;\n\n// call with System.out.println(search(number[],0,100);\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 121\n\n"

11 – Rekursion Beispiel: 3D - Gebirge,"11 – Rekursion\n\nBeispiel: 3D - Gebirge\n\n1. Gegeben sei ein Rechteck, indem jede Ecke mit einer zufälligen Höhe \n\ninitialisiert ist (kann auch 0 sein)\n\n2. Für die Unterteilung AB wird der Mittelwert aus den Höhen A und B gebildet \n\nund eine zufällige Abweichung [+/- deviation] aufaddiert\n\n3. Genauso werden AC,BD,CD und M Höhen zugewiesen.\n\n4. Deviation wird halbiert\n\n5. Es werden 4 neue Rechecke bei\n\nA,AC,M,AB ;  AC,C,CD,M ; CD,D,BD,M  \n\nAB,M,BD,B definiert, in denen mit Punkt 2 \n\nfortgefahren wird bis die notwendige Auflösung \n\nerreicht ist\n\n6. Man zeichne das Gebirge\n\nA\n\nAC\n\nAB\n\nM\n\nC\n\nCD\n\nB\n\nBD\n\nD\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 122\n\n 11 – Rekursion\n\nBeispiel: 3D - Gebirge\n\n Zusätzlich wird hier alle Höhen <0 auf 0 gesetzt und blau gefüllt (Wasser)\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 123\n\n"

12 – Klassen und Objekte Kapitel 12 – Klassen und Objekte,12 – Klassen und Objekte\n\nKapitel 12 – Klassen und Objekte\n\nKlassendeklaration und Zugriff auf Klassenelemente\n\nDeklaration von Instanz- und Klassenvariablen\n\n\n\n\n\n\n\n\n\n\n\n\n\nDer Konstruktor\n\nÜberladen von Methoden\n\nDer static Initialisierer\n\nObjektzerstörung\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 125\n\n

12 – Klassen und Objekte Klassen und Objekte,12 – Klassen und Objekte\n\nKlassen und Objekte\n\n\n\nEine Klasse ist ein Bauplan während ein Objekt die mit Hilfe des Bauplans \n\nerstellte Umsetzung ist.\n\nKlasse                                     Objekt\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 126\n\n

12 – Klassen und Objekte Klassendeklaration und Zugriff auf Klassenelemente,"12 – Klassen und Objekte\n\nKlassendeklaration und Zugriff auf Klassenelemente\n\n\n\nMit einer Klassendeklaration definiert man einen Referenztypen und legt \n\nderen Implementierung fest.\n\nMit der Deklaration einer Klasse „Haus“ würde also eine Referenz (eine Art \n\nZeiger) festgelegt, die nur auf Häuser zeigen kann. Die Klasse Haus \n\ndefiniert dabei, wieviele Zimmer, Türen und Fenster das Haus hat.\n\n\n\nJede Klasse (außer Object) ist implizit Subklasse der Klasse Object, die \n\nWurzel in der JAVA Vererbungshierarchie ist.\n\nAm Anfang war also die Klasse „Object“ und alle neu definierten Klassen \n\nenthalten die Grundfunktionalität der Klasse Object, z.B. die Funktion \n\ntoString()\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 127\n\n 12 – Klassen und Objekte\n\nKlassendeklaration und Zugriff auf Klassenelemente\n\n\n\nInnerhalb der Klasse kann Folgendes deklariert werden:\n\n\n\n\n\n\n\n\n\n\n\nVariablen beliebigen Typs\n\nverändern\n\nMethoden, d.h. Funktionen, die den Zustand des Objekts auslesen oder \n\nKonstruktoren, d.h. Methoden, die das Objekt initialisieren\n\nStatic Initialisierer, d.h. spezielle Anweisungsfolgen zur Initialisierung\n\nEingebettete Klassen, d.h.klassen,die nur lokal benötigt werden\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 128\n\n 12 – Klassen und Objekte\n\nKlassendeklaration und Zugriff auf Klassenelemente\n\nBeispiel einer Klasse:            \n\nimport java.io.*;\n\npublic class Clock {\n\nthis.hour = hour;\n\nthis.minute = minute;\n\nthis.second = second;\n\nprivate int hour, minute, second; // variables\n\npublic Clock(int hour, int minute, int second){ // constructor\n\nSystem.out.println(""It is "" + this.hour + "":"" \n\n                 + this.minute + "":"" + this.second + "" o\'clock!"");\n\npublic static void main(String[] arg){\n\nClock personalClock = new Clock(12,13,22);\n\n}\n\n}\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 129\n\n"

12 – Klassen und Objekte Instanz und Klassenvariablen,"12 – Klassen und Objekte\n\nInstanz und Klassenvariablen\n\n\n\n\n\nDie Variablen innerhalb einer Klasse sollten, wenn möglich, privat sein\n\nAuf Klassenvariablen sollte von aussen immer nur mit setter und getter\n\nMethoden zugegriffen werden.   \n\nimport java.io.*;\n\npublic class Clock {\n\nprivate int hour, minute, second; // variables\n\npublic void setHour(int hour){ this.hour = hour; }\n\n    public int getHour(){ return this.hour }\n\npublic static void main(String[] arg){\n\nClock personalClock = new Clock(1,2,3);\n\n       personalClock.setHour(12);// vor allem von aussen setter\n\n       int nowHour = personalClock.getHour();// und getter\n\n}\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 130\n\n 12 – Klassen und Objekte\n\nInstanz und Klassenvariablen\n\n\n\n\n\n\n\nDie Variablen, die innerhalb der Klasse deklariert sind werden einmal pro \nInstanz/Objekt angelegt (außer static Variablen)\n\nSind sie mit dem Schlüsselwort public versehen, so kann auch von aussen \ndarauf zugegriffen werden.  Das geschieht mittels des Punktoperators z.B.: \n\nObjektname.variablenname = 112;\n\nSind Variablen mit dem Schlüsselwort private versehen, so kann nur \ninnerhalb der Klasse direkt auf die Variablen zugegriffen werden. Von \naussen sind sie nur über setter und getter Methoden direkt änderbar.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 131\n\n"

12 – Klassen und Objekte Der Konstruktor,"12 – Klassen und Objekte\n\nDer Konstruktor\n\n\n\n\n\n\n\n\n\n\n\n\n\nDer Konstruktor ist eine Methode einer Klasse, die denselben Namen wie \ndie Klasse trägt und keinen Rückgabetypen besitzt\n\nDiese Methode wird bei der Instanziierung der Klasse aufgerufen.\n\nIn der Methode werden typischerweise Variablen initialisiert und Speicher \nreserviert.\n\nDer Standard-Konstruktor enthält keine Übergabeparameter.\n\nSollen bei der Instanziierung Werte oder Größen festgelegt werden, so kann \nder Konstruktor überladen werden, d.h. eine Konstruktormethode mit \nÜbergabeparametern definiert werden.\n\nIst der Konstruktor als private deklariert, so kann keine Instanz der Klasse \nvon außen gebildet werden, da ein Aufruf des Konstruktors nötig wäre.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 132\n\n"

12 – Klassen und Objekte Überladen von Methoden,"12 – Klassen und Objekte\n\nÜberladen von Methoden\n\n\n\n\n\nWie wir auf der letzten Folie gelesen haben, kann eine Methode überladen \nwerden, indem die gleiche Methode mit identischem Rückgabetyp, aber \nanderen Übergabeparametern definiert wird\n\nDer Compiler entscheidet dann für jeden Aufruf der Funktion, welche der \nüberladenen Funktionen genommen wird.\n\n   1) public int methode(){return 0;}\n\n   2) public int methode(int a){return a;}\n\n   3) public int methode(float a){return (int)a;}\n\n   methode();    // → Methode 1 wird aufgerufen\n\n   methode(5);   // → Methode 2 wird aufgerufen\n\n   methode(5.5); // → Methode 3 wird aufgerufen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 133\n\n"

12 – Klassen und Objekte Static,"12 – Klassen und Objekte\n\nStatic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDas Schlüsselwort static vor einer Variablen sorgt dafür, dass die Variable \nnur einmal angelegt wird und so nur genau einmal für alle Objekte existiert\n\n„static“ Variablen existieren schon bevor es eine Instanz der Klasse gibt!!!\n\nStatische Methoden können nur auf statische Elemente (Methoden, \nVariablen) zugreifen.\n\nBeispiel für eine statische Methode ist die main Methode.\n\nEin weiteres Beispiel ist das folgende Entwurfsmuster „Lazy Creation“:\n\nInstanziiere ein Objekt als eine statische Instanz \n\nMache den Konstruktor privat\n\nStelle eine statische Methode zur Verfügung, die eine Referenz auf die \nstatische Instanz zurückgibt\n\n → Das Objekt ist nur einmal instanziierbar!!!\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 134\n\n"

12 – Klassen und Objekte Objektzerstörung,"12 – Klassen und Objekte\n\nObjektzerstörung\n\n\n\n\n\n\n\n\n\n\n\nDer JAVA-Garbage-Collector gibt den reservierten Speicherplatz \nautomatisch frei\n\nDer Garbage-Collector ist ein Thread niedrigster Priorität, der periodisch \nüberprüft, ob die Instanzen/Objekte noch referenziert werden\n\nExistiert keine Referenz auf das Objekt, so wird es zerstört bzw. der \nSpeicher freigegeben\n\nEs gibt keine Möglichkeit außer durch Beenden des Programms den \nGarbage-Collector gezielt aufzurufen.\n\nMit der Methode protected void finalize() throws Throwable{...} kann jedoch \nin jeder Klasse eine Methode ergänzt werden, die bei Zerstörung des \nObjekts aufgerufen wird.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 135\n\n"

13 - Vererbung Kapitel 13 – Vererbung,13 - Vererbung\n\nKapitel 13 – Vererbung\n\nVerdeckte Variablen und überschriebene Methoden\n\nVererbung\n\n\n\n\n\n\n\n\n\nAufrufreihenfolge der Konstruktoren\n\nAbstrakte Klassen\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 137\n\n

13 - Vererbung Vererbung,"13 - Vererbung\n\nVererbung\n\nUm JAVA Code ohne Copy/Paste sinnvoll wiederverwenden zu können, \n\nkann eine Klasse vererbt werden.\n\nDas geschieht mit dem Schlüsselwort extends (erweitert)\n\nAlle Methoden der Superklasse (von der geerbt wird) stehen dann \n\nautomatisch in der abgeleiteten Klasse zur Verfügung.\n\n public class StopWatch extends Clock\n\n   //  ohne eine Methode hinzuzufügen, kann man alle\n\n   //  in der Klasse Clock definierten Methoden nutzen \n\n\n\n\n\n\n\n {\n\n }\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 138\n\n"

13 - Vererbung Verdeckte Variablen und überschriebene Methoden,"13 - Vererbung\n\nVerdeckte Variablen und überschriebene Methoden\n\n Wenn Variablen gleichen Namens in der Super- und in der abgeleiteten \n\nKlasse deklariert werden, werden die Variablen der Super-Klasse überdeckt. \n\nAuf sie kann nur mittels super:variablenname zugegriffen werden.\n\n\n\nAuch Methoden gleichen Namens und gleicher Signatur können in der \n\nabgeleiteten Klasse Überschrieben werden.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 139\n\n"

13 - Vererbung Aufrufreihenfolge der Konstruktoren,"13 - Vererbung\n\nAufrufreihenfolge der Konstruktoren\n\n\n\nBeim Instanziieren der abgeleiteten Klasse, wird zunächst der Konstruktor \n\nder super-Klasse (eventuell davor, der der super-super Klasse etc.) \n\naufgerufen. \n\n\n\nDadurch werden bei der Initialisierung erst die super-Klassen Variablen \n\ninitialisiert, dann die der abgeleiteten.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 140\n\n"

13 - Vererbung Abstrakte Klassen,"13 - Vererbung\n\nAbstrakte Klassen\n\n\n\n\n\n\n\n\n\nDurch Vorstellen des Schlüsselwortes abstract (z.B. abstract class \nClock)  kann eine Klasse definiert werden, die nicht instanziiert werden \nkann, sondern nur eine Schablone für abgeleitete Klassen bietet\n\nAuch die Methoden innerhalb der abstrakten Klasse können als abstract \n\ndefiniert werden, ohne Inhalt.\n\nAbstrakte Methoden müssen in allen abgeleiteten Klassen, die nicht abstract \n\nsind, implementiert werden\n\nHat eine abstrakte Klasse weder Variablen, noch Methoden, die nicht als \n\nabstract ohne Methodenrümpfe definiert sind, so wird die Klasse „rein \n\nabstrakte Klasse“ genannt.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 141\n\n"

14 - Referenzen Kapitel 14 – Referenzen,14 - Referenzen\n\nKapitel 14 – Referenzen\n\nReferenzen und primitive Datentypen\n\n\n\n\n\n\n\nAutoboxing und  Unboxing\n\nKopierkonstruktor\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 143\nSeite 143\n\n

14 - Referenzen Referenzen und primitive Datentypen,"14 - Referenzen\n\nReferenzen und primitive Datentypen\n\n\n\n\n\nReferenzen sind „Zeiger“ auf Objekte, beinhalten also eine Speicheradresse\n\nElementare Datentypen oder primitive Datentypen beinhalten den Wert, mit \n\ndem gearbeitet wird.\n\n Wird ein Referenztyp einem anderen Referenztyp zugewiesen, so zeigen \n\nBeide auf das gleiche Objekt\n\n Wird ein primitiver Typ einem anderen zugewiesen, so ändert sich der Wert.\n\n\n\nVergleicht man zwei Referenzen mit dem == Operator, so wird deren \n\nAdresse verglichen und nur, wenn sie auf dasselbe (nicht das gleiche) \n\nObjekt zeigen, ergibt das den Wert true.\n\n\n\nVergleicht man zwei Variablen eines primitiven Datentyps, so werden ihre \n\nWerte verglichen.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 144\n\n 14 - Referenzen\n\nReferenzen und primitive Datentypen\n\n Wird einer Methode eine Referenz übergeben, so wird ihr nur der Zeiger auf \n\ndas Objekt übergeben und das Objekt kann direkt in der Methode verändert \n\nwerden.\n\nOriginal nicht aus.\n\n Wird einer Methode ein primitiver Datentyp übergeben, so wird eine Kopie \n\ndes Wertes erzeugt. Eine Änderung der Kopie wirkt sich aber auf das \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 145\n\n"

14 - Referenzen Autoboxing und Unboxing,14 - Referenzen\n\nAutoboxing und Unboxing\n\n\n\nAutoboxing: ist die automatische Umwandlung eines primitiven Datentyps in \n\ndas zugehörige Objekt der Wrapper-Klasse (z.B. int -> Integer).\n\nInteger weight = new Integer(3);\n\n\n\nUnboxing: ist der umgekehrte Vorgang. Die Umwandlung eines Objekts der \n\nWrapper-Klasse in einen primitiven Datentyp.\n\nint w = weight.intValue();\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 146\n\n

14 - Referenzen Kopierkonstruktor,"14 - Referenzen\n\nKopierkonstruktor\n\n\n\nDer Kopierkonstruktor wird aufgerufen, wenn bei der Instanziierung eines \n\nObjekts ein anderes Objekt der gleichen Klasse übergeben wird.\n\nMyClass myObject = new MyClass(otherObject);\n\n Wird kein Kopierkonstruktor implementiert, so werden alle Variableninhalte \n\neinfach kopiert. Bei primitiven Datentypen ist das kein Problem. Bei \n\nReferenzdatentypen zeigt dann aber die Kopie auf das gleiche Objekt, was \n\nzu unerwünschten Nebeneffekten führt, denn Objekte wie z.B. myObject \n\nund otherObject (siehe obiges Beispiel) würden auf ein gemeinsames \n\nObject referenzieren und wären damit nicht mehr voneinander unabhängig.\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 147\n\n"

" Ein Kopierkonstruktor muss implementiert werden, wenn in der Klasse ","\n\nEin Kopierkonstruktor muss implementiert werden, wenn in der Klasse \n\nReferenztypen benutzt werden, dessen Variablen ebenfalls kopiert werden sollen. \n\n14 - Referenzen\n\nKopierkonstruktor\n\n   CarDisplay displ = new CarDisplay(); \n\npublic class Car{\n\n   int x;\n\nCar(Car obj){\n\n   x = obj.x;\n\n   displ.tacho = obj.displ.tacho;\n\n   displ.clock = obj.displ.clock;\n\n      }\n\n    }\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 148\n\n"

15 – Interfaces 15 - Interfaces,15 – Interfaces\n\n15 - Interfaces\n\nInterfaces\n\n\n\n\n\nInterfaceelemente\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 150\n\n

15 – Interfaces Interfaces,"15 – Interfaces\n\nInterfaces\n\n\n\n\n\n\n\nInterfaces sind ähnlich wie rein abstrakte Klassen\n\nSie haben jedoch eine unabhängige Vererbungshierarchie\n\nEs kann public und abstract vorangestellt werden, gefolgt vom Schlüsselwort \n\ninterface, dann der Name des Interfaces und eventuell extends und eine Liste \n\nvon Superinterfaces.\n\n   public interface Konto{\n\n          double abheben(double betrag);\n\n          double einzahlen(double betrag);\n\n   public class Girokonto implements Konto{\n\n   }\n\n   }\n\n          ....\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 151\n\n"

15 – Interfaces Interfaces Elemente,"15 – Interfaces\n\nInterfaces Elemente\n\nVariablen, die in einem Interface deklariert werden sind implizit public \n\nstatic und final. Es sind klassenspezifische symbolische Konstanten\n\nNeben den Methoden und Variablen, die im Interface deklariert sind hat \n\ndas Interface die aus direkten Superinterfaces geerbten Methoden und \n\n\n\n\n\nVariablen.\n\n\n\nAlle Methoden eines Interfaces sind implizit abstract, d.h. bei ihrer \n\nImplementierung werden nur Ergebnistyp und Signatur einer Methode \n\nfestgelegt. Ein Methodenrumpf entfällt\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 152\n\n"

15 – Interfaces Interfaces als Ersatz für Mehrfachvererbung,"15 – Interfaces\n\nInterfaces als Ersatz für Mehrfachvererbung\n\n Warum also Interfaces, wenn man auch abstrakte Klassen nehmen könnte?\n\n\n\n\n\nJava erlaubt keine Mehrfachvererbung, es ist also in Java nicht möglich von \n\nmehreren Klassen zu erben. \n\nEin Beispiel für Mehrfachvererbung ist, wenn man ein Amphibienfahrzeug \n\nvon der Klasse Fahrzeug und Boot ableitet, um sowohl die Methoden eines \n\nFahrzeugs, als auch die eines Bootes benutzen zu können.\n\n\n\nAls Ersatz erlaubten die Entwickler der Sprache Java die Möglichkeit \n\nmehrere Interfaces in einer Klasse implementieren zu können\n\nclass AmphibienFahrzeug implements Fahrzeug implements Boot \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 153\n\n"

15 – Exceptions 16 - Exceptions,"15 – Exceptions\n\n16 - Exceptions\n\nGeprüfte-, ungeprüfte Exceptions und Fehler \n\nBehandlung einer Exception (Try-Catch-Finally)\n\n\n\n\n\n\n\nBeispiel\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 155\n\n"

"16 – Exceptions Geprüfte-, ungeprüfte Exceptions und Fehler","16 – Exceptions\n\nGeprüfte-, ungeprüfte Exceptions und Fehler\n\nGeprüfte Exceptions (Ausnahmebehandlung) werden zur Compilierzeit \n\nvom Compiler geprüft\n\nUngeprüfte Exceptions treten während der Laufzeit auf und werden vom \n\nCompiler nicht geprüft. (Beispiel Division durch 0)\n\nFehler können normalerweise nicht rückgängig gemacht werden.\n\n\n\n\n\n\n\n \n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 156\n\n"

16 – Exceptions Behandlung einer Exception,"16 – Exceptions\n\nBehandlung einer Exception\n\n\n\nFalls von einer Methode eine Exception ausgelöst werden kann, die \n\nBehandlung aber irgendwo in der Aufrufhierarchie erfolgen soll, so muss in \n\nder Methodendeklaration die throws-Klausel stehen.\n\n\n\n\n\n\n\n\n\nDer Programmteil, der eine Exception auslösen kann, wird in einen try-Block \n\neingeschlossen.\n\nDer Programmteil, der die Exception behandelt folgt, in einem catch-Block. \n\nDabei sollten zuerst die spezielleren Ausnahmebehandlungen mit einem \n\ncatch Block abgefangen werden, gefolgt von allgemeineren catch Blöcken.\n\nAm Ende einer in einem try-catch Block behandelten Ausnahme, wird ein \n\noptionaler finally Block ausgeführt. Dies geschieht unabhängig davon, ob \n\neine Ausnahmebehandlung stattgefunden hat, oder nicht.\n\n\n\nEine Exception Behandlung kann kontrolliert mit dem Schlüsselwort throw \n\nausgelöst werden (Beispiel: throw new EOFException();)\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 157\n\n"

16 – Exceptions Beispiel,"16 – Exceptions\n\nBeispiel\n\npublic class Main {\n\npublic static void main(String[] args) {\n\ntry {\n\nint test[] = new int[100];\n\ntest[200] = 3;\n\n} catch (ArrayIndexOutOfBoundsException aobEx) {\n\nSystem.out.println(""Array index out of bounds..."");\n\naobEx.printStackTrace();\n\n} catch (Exception e){//all other exceptions\n\n   \n\n}\n\n}\n\n}\n\nJörn Fischer  -  j.fischer@hs-mannheim.de - Raum A112\n\nSeite 158\n\n"

